---
title: Visualizing Humanoid Robots with URDF
description: Explore the Unified Robot Description Format (URDF) for modeling and visualizing the physical structure of humanoid robots in ROS 2.
slug: /chapter1/urdf-humanoids
---

# Visualizing Humanoid Robots with URDF

The Unified Robot Description Format (URDF) is an XML file format used in ROS to describe all aspects of a robot. In this section, we'll focus on how URDF is used to define the physical structure and kinematics of humanoid robots, allowing for their visualization and simulation within the ROS 2 ecosystem.

## URDF Fundamentals

The Unified Robot Description Format (URDF) is an XML-based file format used in ROS to describe all aspects of a robot. It serves as a declarative language for specifying the robot's kinematic and dynamic properties, visual appearance, and collision geometry. While URDF can describe any type of robot, its application for complex structures like humanoid robots is particularly powerful, allowing for a standardized way to represent their intricate physical makeup.

**Purpose of URDF:**

*   **Robot Visualization**: URDF files are primarily used by tools like RViz (ROS Visualization) to display a 3D model of the robot, enabling developers to visually inspect its design, joint movements, and sensor placements. This is crucial for understanding a humanoid robot's physical interactions.
*   **Simulation**: Robot simulators (e.g., Gazebo) use URDF to create realistic simulations of robots in virtual environments. This allows for testing control algorithms, AI behaviors, and safety protocols without requiring physical hardware.
*   **Path Planning and Motion Control**: The kinematic and dynamic information encoded in URDF is essential for inverse kinematics calculations, collision detection, and motion planning algorithms, which are vital for humanoid robots to navigate and interact with their environment.
*   **Hardware Abstraction**: URDF provides a common interface to describe the robot's physical properties, decoupling the high-level control software from the specific hardware implementation.

At its core, a URDF file defines a robot as a collection of rigid bodies (called **links**) connected by various types of **joints**. This hierarchical structure allows for precise modeling of how different parts of a humanoid robot move relative to each other. Understanding these fundamental components is key to working with URDF.

## Links and Joints: Building Blocks of a Robot

A URDF file begins with a `<robot>` tag that encapsulates the entire robot description. Within this, the two most fundamental elements are `<link>` and `<joint>`.

### Links: The Robot's Rigid Bodies

A `<link>` element represents a rigid body of the robot. This could be anything from a robot's torso, a limb segment, a wheel, or a sensor housing. Each link has several optional properties that define its physical and visual characteristics:

*   **`<visual>`**: Describes how the link looks in a simulator or visualization tool. It includes:
    *   **`<geometry>`**: Defines the shape (box, cylinder, sphere, mesh).
    *   **`<material>`**: Specifies color and texture.
    *   **`<origin>`**: Defines the offset of the visual element relative to the link's origin.
*   **`<collision>`**: Describes the collision properties of the link, used for physics simulation and collision detection. Often, a simplified geometry is used here for computational efficiency. It also has:
    *   **`<geometry>`**: Defines the collision shape.
    *   **`<origin>`**: Defines the offset.
*   **`<inertial>`**: Defines the mass properties of the link, crucial for accurate physics simulation. It includes:
    *   **`<mass>`**: The link's mass in kilograms.
    *   **`<inertia>`**: A 3x3 rotational inertia matrix.
    *   **`<origin>`**: Defines the center of mass.

**Example Link Structure (conceptual):**

```xml
<link name="base_link">
  <visual>
    <geometry><box size="0.1 0.1 0.1" /></geometry>
    <material name="blue" />
  </visual>
  <collision>
    <geometry><box size="0.1 0.1 0.1" /></geometry>
  </collision>
  <inertial>
    <mass value="1.0" />
    <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01" />
  </inertial>
</link>
```

### Joints: Connecting the Links

A `<joint>` element defines the kinematic and dynamic properties of the connection between two links. Joints are what allow a robot to move. Key attributes and elements of a joint include:

*   **`name`**: A unique identifier for the joint.
*   **`type`**: The type of joint, specifying its allowed motion. Common types include:
    *   `revolute`: A single rotational degree of freedom (e.g., a hinge).
    *   `continuous`: A revolute joint with no upper or lower limits.
    *   `prismatic`: A single translational degree of freedom (e.g., a piston).
    *   `fixed`: No movement between the two links (e.g., joining a camera to a robot's head).
*   **`<parent link="parent_link_name" />`**: Specifies the name of the parent link.
*   **`<child link="child_link_name" />`**: Specifies the name of the child link.
*   **`<origin xyz="x y z" rpy="roll pitch yaw" />`**: Defines the transform from the parent link's origin to the child link's origin (where `xyz` is translation and `rpy` is rotation in radians).
*   **`<axis xyz="x y z" />`**: For revolute and prismatic joints, this specifies the axis of motion relative to the joint's origin.
*   **`<limit>`**: For `revolute` and `prismatic` joints, defines the upper and lower position limits, velocity limits, and effort limits.
*   **`<dynamics>`**: Defines friction and damping coefficients for the joint.

**Example Joint Structure (conceptual):**

```xml
<joint name="base_to_torso" type="revolute">
  <parent link="base_link" />
  <child link="torso_link" />
  <origin xyz="0 0 0.05" rpy="0 0 0" />
  <axis xyz="0 0 1" />
  <limit effort="1000.0" velocity="0.5" lower="-1.57" upper="1.57" />
</joint>
```

By combining various links and joints, complex kinematic chains like those found in humanoid robots can be accurately modeled in URDF, forming the basis for their control and simulation.

## Simple Humanoid URDF Example

Let's construct a simple URDF for a basic humanoid robot. This example will include a base, torso, head, and two arms, connected by a mix of fixed and revolute joints. This minimalist design helps illustrate the core concepts of links and joints without unnecessary complexity.

```xml
<?xml version="1.0"?>
<robot name="simple_humanoid">

  <!-- Base Link -->
  <link name="base_link">
    <visual>
      <geometry><box size="0.2 0.3 0.1" /></geometry>
      <material name="blue">
        <color rgba="0 0 1 1" />
      </material>
    </visual>
    <collision>
      <geometry><box size="0.2 0.3 0.1" /></geometry>
    </collision>
    <inertial>
      <mass value="5.0" />
      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1" />
    </inertial>
  </link>

  <!-- Torso Link -->
  <link name="torso_link">
    <visual>
      <geometry><box size="0.2 0.15 0.3" /></geometry>
      <material name="grey">
        <color rgba="0.7 0.7 0.7 1" />
      </material>
    </visual>
    <collision>
      <geometry><box size="0.2 0.15 0.3" /></geometry>
    </collision>
    <inertial>
      <mass value="10.0" />
      <inertia ixx="0.5" ixy="0.0" ixz="0.0" iyy="0.5" iyz="0.0" izz="0.5" />
    </inertial>
  </link>

  <!-- Base to Torso Joint -->
  <joint name="base_to_torso_joint" type="fixed">
    <parent link="base_link" />
    <child link="torso_link" />
    <origin xyz="0 0 0.2" rpy="0 0 0" />
  </joint>

  <!-- Head Link -->
  <link name="head_link">
    <visual>
      <geometry><sphere radius="0.1" /></geometry>
      <material name="white">
        <color rgba="1 1 1 1" />
      </material>
    </visual>
    <collision>
      <geometry><sphere radius="0.1" /></geometry>
    </collision>
    <inertial>
      <mass value="2.0" />
      <inertia ixx="0.05" ixy="0.0" ixz="0.0" iyy="0.05" iyz="0.0" izz="0.05" />
    </inertial>
  </link>

  <!-- Torso to Head Joint -->
  <joint name="torso_to_head_joint" type="revolute">
    <parent link="torso_link" />
    <child link="head_link" />
    <origin xyz="0 0 0.2" rpy="0 0 0" />
    <axis xyz="0 0 1" />
    <limit lower="-1.57" upper="1.57" effort="10" velocity="1.0" />
  </joint>

  <!-- Right Arm Link -->
  <link name="right_arm_link">
    <visual>
      <geometry><cylinder radius="0.03" length="0.2" /></geometry>
      <material name="red">
        <color rgba="1 0 0 1" />
      </material>
    </visual>
    <collision>
      <geometry><cylinder radius="0.03" length="0.2" /></geometry>
    </collision>
    <inertial>
      <mass value="1.0" />
      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01" />
    </inertial>
  </link>

  <!-- Torso to Right Arm Joint -->
  <joint name="torso_to_right_arm_joint" type="revolute">
    <parent link="torso_link" />
    <child link="right_arm_link" />
    <origin xyz="-0.12 0 0.1" rpy="0 0 0" />
    <axis xyz="0 1 0" />
    <limit lower="-1.57" upper="1.57" effort="10" velocity="1.0" />
  </joint>

  <!-- Left Arm Link -->
  <link name="left_arm_link">
    <visual>
      <geometry><cylinder radius="0.03" length="0.2" /></geometry>
      <material name="green">
        <color rgba="0 1 0 1" />
      </material>
    </visual>
    <collision>
      <geometry><cylinder radius="0.03" length="0.2" /></geometry>
    </collision>
    <inertial>
      <mass value="1.0" />
      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01" />
    </inertial>
  </link>

  <!-- Torso to Left Arm Joint -->
  <joint name="torso_to_left_arm_joint" type="revolute">
    <parent link="torso_link" />
    <child link="left_arm_link" />
    <origin xyz="0.12 0 0.1" rpy="0 0 0" />
    <axis xyz="0 1 0" />
    <limit lower="-1.57" upper="1.57" effort="10" velocity="1.0" />
  </joint>

</robot>
```

**Explanation of Components:**

*   **`<robot name="simple_humanoid">`**: The root tag, giving the robot a name.
*   **Links (`<link>`)**:
    *   `base_link`: The foundation of our humanoid, a simple box representing the base.
    *   `torso_link`: Connected to the `base_link`, forming the main body.
    *   `head_link`: A spherical head connected to the torso.
    *   `right_arm_link` and `left_arm_link`: Cylindrical arms attached to the torso.
    *   Each link has `<visual>`, `<collision>`, and `<inertial>` properties as described in the previous section, defining its appearance, physical interaction, and mass characteristics.
*   **Joints (`<joint>`)**:
    *   `base_to_torso_joint`: A `fixed` joint, meaning the torso is rigidly attached to the base.
    *   `torso_to_head_joint`: A `revolute` joint, allowing the head to rotate around the Z-axis relative to the torso, simulating a head turn. It includes `limit` tags to constrain its motion.
    *   `torso_to_right_arm_joint` and `torso_to_left_arm_joint`: `revolute` joints for the arms, allowing them to swing forward and backward. These also have motion limits.
    *   The `<origin>` tag in each joint is crucial, specifying the position and orientation of the child link relative to the parent link.

This simple URDF serves as a foundational example. Real-world humanoid robots would feature significantly more complex kinematic chains, additional sensors, and actuators, but the underlying principles of defining links and joints remain the same.

## Visualizing URDF Models (e.g., using RViz)

Once you've created a URDF file for your robot, the next crucial step is to visualize it to ensure that the links and joints are correctly defined and positioned. RViz (ROS Visualization) is the primary 3D visualizer in the ROS ecosystem, offering a powerful way to inspect your robot model, sensor data, and planning outputs.

Hereâ€™s a general workflow and tips for visualizing your URDF model in RViz:

1.  **Ensure ROS 2 Environment is Sourced**:
    As always, before running any ROS 2 tools, make sure your ROS 2 environment is sourced in your terminal.

    ```bash
    source /opt/ros/humble/setup.bash # Replace humble with your ROS 2 distro
    ```

2.  **Launch `robot_state_publisher`**:
    The `robot_state_publisher` is a ROS 2 package that reads the URDF file and publishes the robot's joint states as transformations on the `/tf` topic. RViz uses these transformations to render the robot model.

    First, ensure you have `xacro` and `robot_state_publisher` installed:
    ```bash
    sudo apt install ros-<ros2-distro>-xacro ros-<ros2-distro>-robot-state-publisher
    ```
    Then, launch it with your URDF:
    ```bash
    # Navigate to your package or where your URDF is located
    # Example: if simple_humanoid.urdf is in ~/my_robot_description/urdf/
    # cd ~/my_robot_description

    ros2 launch urdf_tutorial display.launch.py model:=./path/to/simple_humanoid.urdf
    # Or more generally:
    # ros2 run robot_state_publisher robot_state_publisher --ros-args -p robot_description:="`cat book-prac/docs/chapter1/assets/simple_humanoid.urdf`"
    ```
    For the latter command, ensure you replace `book-prac/docs/chapter1/assets/simple_humanoid.urdf` with the actual path to your URDF file. This command reads the URDF content and passes it to the `robot_state_publisher`.

3.  **Launch RViz**:
    Open a new terminal (and source your ROS 2 environment again) and launch RViz:

    ```bash
    ros2 run rviz2 rviz2
    ```

4.  **Configure RViz to Display Your Robot Model**:
    Once RViz is open, you'll need to add displays to visualize your robot:
    *   **Add "RobotModel" Display**: Click "Add" -> "By display type" -> "RobotModel". In the "RobotModel" properties, ensure "Description Topic" is set to "robot_description" (this is the default topic where `robot_state_publisher` puts the URDF).
    *   **Set "Fixed Frame"**: In the "Global Options" section (usually at the top left), set the "Fixed Frame" to the base link of your robot, which is `base_link` for our `simple_humanoid`. This tells RViz which frame to use as the stationary reference.
    *   **Add "TF" Display (Optional)**: To visualize the coordinate frames of each link and joint, add the "TF" display. This helps in debugging joint origins and orientations.

5.  **Manipulate Joints (Optional)**:
    If your robot has revolute or prismatic joints, you can manipulate them to see your robot move. This usually requires a `joint_state_publisher_gui` or a custom controller.

    ```bash
    # Install if not present
    sudo apt install ros-<ros2-distro>-joint-state-publisher-gui

    # Run the GUI
    ros2 run joint_state_publisher_gui joint_state_publisher_gui
    ```
    This GUI will publish joint states on the `/joint_states` topic, which `robot_state_publisher` will then read and update the transforms for RViz.

**Troubleshooting Tips:**

*   **Model not appearing**: Double-check that `robot_state_publisher` is running and correctly loaded your URDF. Ensure "Fixed Frame" in RViz matches your robot's base link.
*   **Links flying apart**: This usually indicates incorrect joint definitions (e.g., missing parent/child links) or issues with the `origin` transforms.
*   **`TF` errors**: Ensure `robot_state_publisher` is publishing `/tf` data correctly. Check `ros2 run rqt_tf_tree rqt_tf_tree` for a visual representation of your transform tree.

Visualizing your URDF model is an iterative process. Don't be discouraged if it doesn't look perfect on the first try. Experiment with link dimensions, joint positions, and display settings in RViz to achieve the desired representation of your humanoid robot.